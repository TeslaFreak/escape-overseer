'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fontPicker = require('font-picker');
var throttle = _interopDefault(require('lodash.throttle'));
var PropTypes = _interopDefault(require('prop-types'));
var React = require('react');
var React__default = _interopDefault(React);

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

var propTypes = {
  apiKey: PropTypes.string.isRequired,
  activeFont: PropTypes.string.isRequired,
  onChange: PropTypes.func.isRequired,
  options: PropTypes.shape({
    name: PropTypes.string,
    families: PropTypes.arrayOf(PropTypes.string),
    categories: PropTypes.arrayOf(PropTypes.string),
    variants: PropTypes.arrayOf(PropTypes.string),
    limit: PropTypes.number,
    sort: PropTypes.oneOf(['alphabetical', 'popularity'])
  })
};
var THROTTLE_INTERVAL = 250;
/**
 * React interface for the font picker
 * @see README.md
 */

var FontPicker =
/*#__PURE__*/
function (_Component) {
  _inherits(FontPicker, _Component);

  function FontPicker(props) {
    var _this;

    _classCallCheck(this, FontPicker);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(FontPicker).call(this, props));
    _this.state = {
      activeFont: _this.props.activeFont,
      errorText: '',
      expanded: false,
      loadingStatus: 'loading' // possible values: 'loading', 'finished', 'error'

    }; // Determine selector suffix from font picker's name

    if (_this.props.options && _this.props.options.name) {
      _this.pickerSuffix = "-".concat(_this.props.options.name);
    } else {
      _this.pickerSuffix = '';
    } // initialize FontManager object and generate the font list


    _this.fontManager = new fontPicker.FontManager(_this.props.apiKey, _this.props.activeFont, _this.props.options);

    _this.fontManager.init().then(function () {
      // font list has finished loading
      _this.setState({
        errorText: '',
        loadingStatus: 'finished'
      });
    }).catch(function (err) {
      // error while loading font list
      _this.setState({
        errorText: 'Error trying to fetch the list of available fonts',
        loadingStatus: 'error'
      });

      console.error(_this.state.errorText);
      console.error(err);
    }); // function bindings


    _this.onClose = _this.onClose.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.onScroll = _this.onScroll.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.setActiveFont = _this.setActiveFont.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.downloadPreviews = throttle(_this.downloadPreviews.bind(_assertThisInitialized(_assertThisInitialized(_this))), THROTTLE_INTERVAL);
    _this.toggleExpanded = _this.toggleExpanded.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }
  /**
   * After every component update, check whether the activeFont prop has changed. If so, change the
   * font in the fontManager as well
   */


  _createClass(FontPicker, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      if (this.state.activeFont !== this.props.activeFont) {
        this.setActiveFont(this.props.activeFont);
      }
    }
    /**
     * EventListener for closing the font picker when clicking anywhere outside it
     */

  }, {
    key: "onClose",
    value: function onClose(e) {
      var targetElement = e.target; // clicked element

      do {
        if (targetElement === document.getElementById('font-picker')) {
          // click inside font picker
          return;
        } // move up the DOM


        targetElement = targetElement.parentNode;
      } while (targetElement); // click outside font picker


      this.toggleExpanded();
    }
    /**
     * Scroll event handler
     */

  }, {
    key: "onScroll",
    value: function onScroll(e) {
      e.persist();
      this.downloadPreviews(e);
    }
    /**
     * Set the font with the given font list index as the active one
     */

  }, {
    key: "setActiveFont",
    value: function setActiveFont(fontFamily) {
      var activeFontIndex = this.fontManager.setActiveFont(fontFamily);

      if (activeFontIndex === -1) {
        // error trying to change font
        this.setState({
          activeFont: fontFamily,
          errorText: "Cannot update activeFont: The font \"".concat(fontFamily, "\" is not in the font list"),
          loadingStatus: 'error'
        });
        console.error(this.state.errorText);
      } else {
        // font change successful
        this.setState({
          activeFont: fontFamily,
          errorText: '',
          loadingStatus: 'finished'
        });
      }
    }
    /**
     * Download the font previews for all visible font entries and the five after them
     */

  }, {
    key: "downloadPreviews",
    value: function downloadPreviews(e) {
      var elementHeight = e.target.scrollHeight / this.fontManager.fonts.length;
      var downloadIndex = Math.ceil((e.target.scrollTop + e.target.clientHeight) / elementHeight);
      this.fontManager.downloadPreviews(downloadIndex + 5);
    }
    /**
     * Expand/collapse the picker's font list
     */

  }, {
    key: "toggleExpanded",
    value: function toggleExpanded() {
      if (this.state.expanded) {
        this.setState({
          expanded: false
        });
        document.removeEventListener('click', this.onClose);
      } else {
        this.setState({
          expanded: true
        });
        document.addEventListener('click', this.onClose);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      // generate <ul> with font list; fetch font previews on scroll
      var fontList;

      if (this.state.loadingStatus === 'finished') {
        fontList = React__default.createElement("ul", {
          className: this.state.expanded ? 'expanded' : '',
          onScroll: this.onScroll
        }, this.fontManager.fonts.map(function (font) {
          var isActive = font.family === _this2.state.activeFont;
          var fontId = font.family.replace(/\s+/g, '-').toLowerCase();
          return React__default.createElement("li", {
            key: font.family
          }, React__default.createElement("button", {
            type: "button",
            className: "font-".concat(fontId).concat(_this2.pickerSuffix, " ").concat(isActive ? 'active-font' : ''),
            onClick: function onClick() {
              _this2.toggleExpanded();

              _this2.props.onChange(font);
            },
            onKeyPress: function onKeyPress() {
              _this2.toggleExpanded();

              _this2.props.onChange(font);
            }
          }, font.family));
        }));
      } // render font picker button and attach font list to it


      return React__default.createElement("div", {
        id: "font-picker".concat(this.pickerSuffix),
        title: this.state.errorText
      }, React__default.createElement("button", {
        type: "button",
        className: "dropdown-button ".concat(this.state.expanded ? 'expanded' : ''),
        onClick: this.toggleExpanded,
        onKeyPress: this.toggleExpanded
      }, React__default.createElement("p", {
        className: "dropdown-font-name"
      }, this.state.activeFont), React__default.createElement("div", {
        className: "dropdown-icon ".concat(this.state.loadingStatus)
      })), this.state.loadingStatus === 'finished' && fontList);
    }
  }]);

  return FontPicker;
}(React.Component);
FontPicker.propTypes = propTypes;

module.exports = FontPicker;
